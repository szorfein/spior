# frozen_string_literal: true

require 'digest'
require 'tempfile'
require 'auth'

module Spior
  module Tor
    # Generate a config file (torrc) for Spior
    class Config
      # ==== Attributes
      #
      # * +filename+ - A reference to a tempfile like filename=Tempfile.new('foo')
      #
      def initialize(filename)
        @filename = filename
        @config_torrc = '/etc/tor/torrc'
        @config_dir = '/etc/torrc.d'
        @config_spiorrc = "#{@config_dir}/spior.conf"
        @content = ['# Generated by Spior, don\'t edit.']
        @content_torrc = []
      end

      # Generate a `torrc` compatible file for Spior
      # Use value from Spior::CONFIG
      def generate
        create_config_dir
        configure_torrc
        generate_content(@content)
        return if @content.length == 1

        cn = @content.join("\n")
        File.write(@filename.path, "#{cn}\n")
        Msg.p "Generating #{@config_spiorrc}..."
        move(@filename.path, @config_spiorrc)
      end

      def write_file(content, file, mode = 'a')
        return if content.nil?

        File.open(file, mode) do |f|
          if content.is_a?(Array)
            f.puts(content.join('\n'))
          else
            f.puts(content)
          end
          # f.chmod(644)
        end
      end

      # Save current Tor options (Spior::CONFIG) in /etc/tor/torrc
      # Only if theses options are not alrealy present
      def backup
        generate_content(@content_torrc)
        write_file @content_torrc, @filename.path, 'w'

        Msg.p 'Saving Tor options...'
        move(@filename.path, @config_spiorrc)
      end

      protected

      def create_config_dir
        return if Dir.exist? @config_dir

        if Process::Sys.getuid == '0'
          File.mkdir @config_dir
        else
          Auth.new.mkdir @config_dir
        end
      end

      def configure_torrc
        temp = Tempfile.new('torrc')
        content = File.read(@config_torrc)
        adding content, "%include #{@config_dir}/*.conf"
        write_file content, temp.path
        move(temp.path, @config_torrc)
      end

      def generate_content(content)
        adding content, 'AutomapHostsOnResolve 1'
        adding content, "DNSPort #{CONFIG.dns_port}"
        adding content, "VirtualAddrNetworkIpv4 #{CONFIG.virt_addr}"
        adding content, "TransPort #{CONFIG.trans_port} IsolateClientAddr
               IsolateClientProtocol IsolateDestAddr IsolateDestPort"
      end

      private

      def search(option_name)
        File.open(@config_torrc) do |f|
          f.each do |line|
            return Regexp.last_match(1) if line.match(%r{^#{option_name} ([a-z0-9./*]*)}i)
          end
        end
        false
      end

      def adding(content, option)
        o = option.split(' ')
        all = o[1..o.length].join(' ')
        return if search(o[0])

        content << "#{o[0]} #{all}"
      end

      def digest_match?(src, dest)
        return unless File.exist?(dest) && File.readable?(dest)

        md5_src = Digest::MD5.file src
        md5_dest = Digest::MD5.file dest
        md5_src == md5_dest
      end

      # Permission for Archlinux on a torrc are chmod 644, chown root:root
      def fix_perm(file)
        if Process::Sys.getuid == '0'
          file.chown(0, 0)
        else
          Helpers::Exec.new('chown').run("root:root #{file}")
        end
      end

      def move(src, dest)
        return if digest_match? src, dest

        fix_perm(@filename.path)
        if Process::Sys.getuid == '0'
          FileUtils.mv(src, dest)
        else
          Helpers::Exec.new('mv').run("#{src} #{dest}")
        end
      end
    end
  end
end
